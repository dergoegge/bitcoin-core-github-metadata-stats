<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Core GitHub Stats</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen">
  <div class="max-w-6xl mx-auto px-6 py-10">
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-8">
      <div>
        <h1 class="text-3xl font-bold text-white mb-1">Bitcoin Core GitHub Stats</h1>
        <p class="text-gray-400">PR authors and comment activity per period (bitcoin/bitcoin)</p>
      </div>
      <!-- Timeframe selector -->
      <div id="timeframePicker" class="flex bg-gray-900 rounded-lg border border-gray-800 p-1 gap-1 self-start"></div>
    </div>

    <!-- Summary cards -->
    <div id="summary" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-10"></div>

    <!-- Charts -->
    <div class="space-y-8 mb-10">
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-4">Unique PR Authors</h2>
        <div class="relative overflow-x-auto"><div id="wrapUnique"><canvas id="chartUnique"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">All PR Authors Breakdown</h2>
        <p class="text-gray-500 text-sm mb-4">Authors with merged PRs (returning + first-time) and authors whose PRs were not merged</p>
        <div class="relative overflow-x-auto"><div id="wrapCombined"><canvas id="chartCombined"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Contributors with Merge Access</h2>
        <p class="text-gray-500 text-sm mb-4">People who merged at least one PR during each period</p>
        <div class="relative overflow-x-auto"><div id="wrapMergeAccess"><canvas id="chartMergeAccess"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Merged PRs by Merger</h2>
        <p class="text-gray-500 text-sm mb-4">Number of PRs merged, broken down by who performed the merge</p>
        <div class="relative overflow-x-auto"><div id="wrapMergedBy"><canvas id="chartMergedBy"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Average Time to Merge</h2>
        <p class="text-gray-500 text-sm mb-4">Mean, mean excluding top 5 authors by PR count, mean excluding maintainers, and median days from PR creation to merge</p>
        <div class="relative overflow-x-auto"><div id="wrapTTM"><canvas id="chartTTM"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Time to Merge by PR Size</h2>
        <p class="text-gray-500 text-sm mb-4">Mean days to merge by patch size: S (&le;50 lines), M (51-500), L (&gt;500)</p>
        <div class="relative overflow-x-auto"><div id="wrapTTMSize"><canvas id="chartTTMSize"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Merged PRs by Author</h2>
        <p class="text-gray-500 text-sm mb-4">Number of merged PRs broken down by PR author (top 15 + others)</p>
        <div class="relative overflow-x-auto"><div id="wrapPRsByAuthor"><canvas id="chartPRsByAuthor"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Comment Authors with &gt;<span id="thresholdLabel"></span> Comments</h2>
        <p class="text-gray-500 text-sm mb-4">Counts comments on both PRs and issues (issue comments, review comments, and code reviews)</p>
        <div class="relative overflow-x-auto"><div id="wrapCommenters"><canvas id="chartCommenters"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Review Activity by PR Age</h2>
        <p class="text-gray-500 text-sm mb-4">Where does review effort go? Reviews and comments bucketed by PR age at time of review (excludes PR author's own activity)</p>
        <div class="relative overflow-x-auto"><div id="wrapReviewAge"><canvas id="chartReviewAge"></canvas></div></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-1">Reviews Received by Author</h2>
        <p class="text-gray-500 text-sm mb-4">Review comments received on PRs, broken down by PR author (top 15 + others, excludes author's own comments)</p>
        <div class="relative overflow-x-auto"><div id="wrapReviewsRecvByAuthor"><canvas id="chartReviewsRecvByAuthor"></canvas></div></div>
      </div>
    </div>

    <!-- Data table -->
    <div class="bg-gray-900 rounded-xl p-6 border border-gray-800 mb-10 overflow-x-auto">
      <h2 class="text-lg font-semibold mb-4">Breakdown</h2>
      <div class="max-h-[28rem] overflow-y-auto">
        <table class="w-full text-sm">
          <thead class="sticky top-0 bg-gray-900 z-10">
            <tr class="text-gray-400 border-b border-gray-800">
              <th class="text-left py-2 px-3">Period</th>
              <th class="text-right py-2 px-3">Merged Authors</th>
              <th class="text-right py-2 px-3">First-Time</th>
              <th class="text-right py-2 px-3">Returning</th>
              <th class="text-right py-2 px-3">Without Merge</th>
              <th class="text-right py-2 px-3">First-Time %</th>
              <th class="text-right py-2 px-3">Merge Access</th>
              <th class="text-right py-2 px-3">Avg TTM</th>
              <th class="text-right py-2 px-3">Med TTM</th>
              <th class="text-right py-2 px-3">Commenters &gt;<span class="thr"></span></th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Contributor stats -->
    <div class="bg-gray-900 rounded-xl p-6 border border-gray-800 mb-10">
      <h2 class="text-lg font-semibold mb-1">Contributor Stats</h2>
      <p class="text-gray-500 text-sm mb-4">Per-contributor averages per period across merged PRs</p>
      <select id="selectContributor" class="mb-4 w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"></select>
      <div id="contributorSummary" class="text-sm text-gray-300 mb-6"></div>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div class="relative overflow-x-auto"><div id="wrapContribPRs"><canvas id="chartContribPRs"></canvas></div></div>
        <div class="relative overflow-x-auto"><div id="wrapContribTTM"><canvas id="chartContribTTM"></canvas></div></div>
      </div>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div class="relative overflow-x-auto"><div id="wrapContribSize"><canvas id="chartContribSize"></canvas></div></div>
        <div class="relative overflow-x-auto"><div id="wrapContribComments"><canvas id="chartContribComments"></canvas></div></div>
      </div>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="relative overflow-x-auto"><div id="wrapContribReviewsRecv"><canvas id="chartContribReviewsRecv"></canvas></div></div>
      </div>
    </div>

    <!-- PR Stats -->
    <div class="bg-gray-900 rounded-xl p-6 border border-gray-800 mb-10">
      <h2 class="text-lg font-semibold mb-1">PR Stats</h2>
      <p class="text-gray-500 text-sm mb-4">Activity heatmap for individual pull requests</p>
      <div class="flex gap-2 mb-4">
        <input type="text" id="prSearch" placeholder="Search by PR number or title..."
          class="flex-1 bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500">
      </div>
      <select id="selectPR" class="mb-4 w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"></select>
      <div id="prSummary" class="text-sm text-gray-300 mb-6"></div>
      <div id="prActivityGraph" class="overflow-x-auto"></div>
    </div>

    <!-- Detail lists -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-10">
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-4">First-Time PR Authors</h2>
        <select id="selectAuthors" class="mb-4 w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"></select>
        <div id="authorList" class="text-sm text-gray-300"></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-4">Merge Access</h2>
        <select id="selectMergeAccess" class="mb-4 w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"></select>
        <div id="mergeAccessList" class="text-sm text-gray-300"></div>
      </div>
      <div class="bg-gray-900 rounded-xl p-6 border border-gray-800">
        <h2 class="text-lg font-semibold mb-4">Prolific Commenters</h2>
        <select id="selectCommenters" class="mb-4 w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"></select>
        <div id="commenterList" class="text-sm text-gray-300"></div>
      </div>
    </div>
  </div>

  <script>
    const COLORS = {
      blue: 'rgb(59, 130, 246)',
      orange: 'rgb(249, 115, 22)',
      red: 'rgb(239, 68, 68)',
      green: 'rgb(34, 197, 94)',
      purple: 'rgb(168, 85, 247)',
    };

    const TIMEFRAMES = [
      { key: 'year',    label: '1 Year' },
      { key: 'quarter', label: '90 Days' },
      { key: 'month',   label: '1 Month' },
    ];

    Chart.defaults.color = 'rgb(156, 163, 175)';
    Chart.defaults.borderColor = 'rgb(55, 65, 81)';

    let DATA = null;
    let activeTF = 'year';
    let charts = {};

    fetch('data.json')
      .then(r => r.json())
      .then(data => {
        DATA = data;
        buildTimeframePicker();
        renderAll();
      });

    function buildTimeframePicker() {
      const el = document.getElementById('timeframePicker');
      el.innerHTML = TIMEFRAMES.map(tf =>
        `<button data-tf="${tf.key}" class="px-3 py-1.5 rounded-md text-sm font-medium transition
          ${tf.key === activeTF ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-gray-200 hover:bg-gray-800'}">${tf.label}</button>`
      ).join('');
      el.onclick = e => {
        const btn = e.target.closest('[data-tf]');
        if (!btn || btn.dataset.tf === activeTF) return;
        activeTF = btn.dataset.tf;
        buildTimeframePicker();
        renderAll();
      };
    }

    function renderAll() {
      const tf = DATA.timeframes[activeTF];
      const periods = tf.periods;
      const unique = periods.map(p => tf.unique_author_counts[p] || 0);
      const noMerge = periods.map(p => tf.no_merge_author_counts[p] || 0);
      const firstTime = periods.map(p => tf.first_time_author_counts[p] || 0);
      const returning = unique.map((u, i) => u - firstTime[i]);
      const prolific = periods.map(p => tf.prolific_commenter_counts[p] || 0);
      const mergeAccess = periods.map(p => tf.merge_access_counts[p] || 0);
      const threshold = DATA.comment_threshold;

      // Threshold labels
      document.getElementById('thresholdLabel').textContent = threshold;
      document.querySelectorAll('.thr').forEach(el => el.textContent = threshold);

      // Labels for x-axis
      const labels = periods.map(p => formatPeriod(p, activeTF));
      const manyPoints = periods.length > 50;
      const minBarWidth = manyPoints ? 6 : 20;

      // Summary cards
      const allUniqueAuthors = new Set();
      for (const arr of Object.values(tf.unique_authors)) arr.forEach(a => allUniqueAuthors.add(a));
      const peakIdx = unique.indexOf(Math.max(...unique));
      const peakFirstIdx = firstTime.indexOf(Math.max(...firstTime));
      const peakProlificIdx = prolific.indexOf(Math.max(...prolific));

      document.getElementById('summary').innerHTML = [
        card('Total Unique PR Authors', allUniqueAuthors.size, 'All time across all periods'),
        card('Peak (Unique)', `${labels[peakIdx]} (${unique[peakIdx]})`, 'Period with most unique PR authors'),
        card('Peak (First-Time)', `${labels[peakFirstIdx]} (${firstTime[peakFirstIdx]})`, 'Period with most new PR authors'),
        card('Peak (Commenters)', `${labels[peakProlificIdx]} (${prolific[peakProlificIdx]})`, `Period with most >${threshold} commenters`),
      ].join('');

      // Charts
      renderChart('chartUnique', 'wrapUnique', {
        labels, minBarWidth, stacked: true,
        datasets: [
          { label: 'Merged', data: unique, backgroundColor: COLORS.blue, borderRadius: 4 },
          { label: 'Without Merge', data: noMerge, backgroundColor: COLORS.red, borderRadius: 4 },
        ],
      });

      renderChart('chartCombined', 'wrapCombined', {
        labels, minBarWidth, stacked: true,
        datasets: [
          { label: 'Returning Authors', data: returning, backgroundColor: COLORS.blue, borderRadius: 4 },
          { label: 'First-Time Authors', data: firstTime, backgroundColor: COLORS.orange, borderRadius: 4 },
          { label: 'Without Merge', data: noMerge, backgroundColor: COLORS.red, borderRadius: 4 },
        ],
      });

      renderChart('chartMergeAccess', 'wrapMergeAccess', {
        labels, minBarWidth,
        datasets: [{ label: 'Merge Access', data: mergeAccess, backgroundColor: COLORS.green, borderRadius: 4 }],
      });

      // Merged PRs by merger — stacked bar, one dataset per person
      {
        const allMergers = new Map(); // merger -> total count (for sorting)
        for (const p of periods) {
          const actors = tf.merges_by_actor[p] || {};
          for (const [u, c] of Object.entries(actors)) {
            allMergers.set(u, (allMergers.get(u) || 0) + c);
          }
        }
        // Sort by total descending
        const sorted = [...allMergers.entries()].sort((a, b) => b[1] - a[1]);
        const palette = [
          'rgb(59, 130, 246)', 'rgb(249, 115, 22)', 'rgb(34, 197, 94)', 'rgb(168, 85, 247)',
          'rgb(236, 72, 153)', 'rgb(234, 179, 8)', 'rgb(20, 184, 166)', 'rgb(239, 68, 68)',
          'rgb(99, 102, 241)', 'rgb(244, 114, 182)', 'rgb(45, 212, 191)', 'rgb(251, 146, 60)',
          'rgb(129, 140, 248)', 'rgb(74, 222, 128)', 'rgb(232, 121, 249)', 'rgb(252, 211, 77)',
        ];
        const datasets = sorted.map(([merger, _], idx) => ({
          label: merger,
          data: periods.map(p => (tf.merges_by_actor[p] || {})[merger] || 0),
          backgroundColor: palette[idx % palette.length],
          borderRadius: 4,
        }));
        renderChart('chartMergedBy', 'wrapMergedBy', {
          labels, minBarWidth, stacked: true, datasets,
        });
      }

      // Average time to merge — line chart with mean + median + filtered means
      {
        const avgTTM = periods.map(p => tf.avg_time_to_merge[p] || 0);
        const medTTM = periods.map(p => tf.median_time_to_merge[p] || 0);
        const avgTTMExcl = periods.map(p => tf.avg_time_to_merge_excl_top5[p] || 0);
        const avgTTMExclMaint = periods.map(p => tf.avg_time_to_merge_excl_maintainers[p] || 0);
        renderChart('chartTTM', 'wrapTTM', {
          labels, minBarWidth, type: 'line',
          datasets: [
            { label: 'Mean (days)', data: avgTTM, borderColor: COLORS.blue, backgroundColor: 'rgba(59,130,246,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
            { label: 'Mean excl. top 5 authors (days)', data: avgTTMExcl, borderColor: COLORS.green, backgroundColor: 'rgba(34,197,94,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
            { label: 'Mean excl. maintainers (days)', data: avgTTMExclMaint, borderColor: COLORS.purple, backgroundColor: 'rgba(168,85,247,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
            { label: 'Median (days)', data: medTTM, borderColor: COLORS.orange, backgroundColor: 'rgba(249,115,22,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
          ],
          yTitle: 'Days',
        });
      }

      // Time to merge by PR size — line chart with S/M/L buckets
      {
        const ttmSize = tf.ttm_by_size || {};
        const sData = periods.map(p => (ttmSize.S || {})[p] || 0);
        const mData = periods.map(p => (ttmSize.M || {})[p] || 0);
        const lData = periods.map(p => (ttmSize.L || {})[p] || 0);
        renderChart('chartTTMSize', 'wrapTTMSize', {
          labels, minBarWidth, type: 'line',
          datasets: [
            { label: 'Small (\u226450 lines)', data: sData, borderColor: COLORS.green, backgroundColor: 'rgba(34,197,94,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
            { label: 'Medium (51-500)', data: mData, borderColor: COLORS.orange, backgroundColor: 'rgba(249,115,22,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
            { label: 'Large (>500)', data: lData, borderColor: COLORS.red, backgroundColor: 'rgba(239,68,68,0.1)', fill: true, tension: 0.3, pointRadius: 2 },
          ],
          yTitle: 'Days',
        });
      }

      // Merged PRs by author — stacked bar, top 15 + Others
      {
        const allAuthors = new Map();
        for (const p of periods) {
          const authors = tf.prs_by_author[p] || {};
          for (const [u, c] of Object.entries(authors)) {
            allAuthors.set(u, (allAuthors.get(u) || 0) + c);
          }
        }
        const sorted = [...allAuthors.entries()].sort((a, b) => b[1] - a[1]);
        const topN = 15;
        const topAuthors = sorted.slice(0, topN).map(([u]) => u);
        const topSet = new Set(topAuthors);
        const palette = [
          'rgb(59, 130, 246)', 'rgb(249, 115, 22)', 'rgb(34, 197, 94)', 'rgb(168, 85, 247)',
          'rgb(236, 72, 153)', 'rgb(234, 179, 8)', 'rgb(20, 184, 166)', 'rgb(239, 68, 68)',
          'rgb(99, 102, 241)', 'rgb(244, 114, 182)', 'rgb(45, 212, 191)', 'rgb(251, 146, 60)',
          'rgb(129, 140, 248)', 'rgb(74, 222, 128)', 'rgb(232, 121, 249)',
        ];
        const datasets = topAuthors.map((author, idx) => ({
          label: author,
          data: periods.map(p => (tf.prs_by_author[p] || {})[author] || 0),
          backgroundColor: palette[idx % palette.length],
          borderRadius: 4,
        }));
        // "Others" bucket
        datasets.push({
          label: 'Others',
          data: periods.map(p => {
            const all = tf.prs_by_author[p] || {};
            return Object.entries(all).reduce((sum, [u, c]) => sum + (topSet.has(u) ? 0 : c), 0);
          }),
          backgroundColor: 'rgb(107, 114, 128)',
          borderRadius: 4,
        });
        renderChart('chartPRsByAuthor', 'wrapPRsByAuthor', {
          labels, minBarWidth, stacked: true, datasets,
        });
      }

      renderChart('chartCommenters', 'wrapCommenters', {
        labels, minBarWidth,
        datasets: [{ label: `Commenters >${threshold}`, data: prolific, backgroundColor: COLORS.purple, borderRadius: 4 }],
      });

      // Review activity by PR age — stacked bar
      {
        const buckets = tf.review_by_pr_age_buckets || [];
        const agePalette = [
          'rgb(34, 197, 94)',    // <1w  — green (fresh)
          'rgb(74, 222, 128)',   // 1-4w — light green
          'rgb(234, 179, 8)',    // 1-3m — yellow
          'rgb(249, 115, 22)',   // 3-6m — orange
          'rgb(239, 68, 68)',    // 6-12m — red
          'rgb(168, 85, 247)',   // 1-2y — purple
          'rgb(107, 114, 128)',  // 2y+  — gray
        ];
        const bucketLabels = {
          '<1w': '< 1 week', '1-4w': '1\u20134 weeks', '1-3m': '1\u20133 months',
          '3-6m': '3\u20136 months', '6-12m': '6\u201312 months', '1-2y': '1\u20132 years', '2y+': '2+ years',
        };
        const datasets = buckets.map((bucket, idx) => ({
          label: bucketLabels[bucket] || bucket,
          data: periods.map(p => (tf.review_by_pr_age[p] || {})[bucket] || 0),
          backgroundColor: agePalette[idx % agePalette.length],
          borderRadius: 4,
        }));
        renderChart('chartReviewAge', 'wrapReviewAge', {
          labels, minBarWidth, stacked: true, datasets,
        });
      }

      // Reviews received by author — stacked bar, top 15 + Others
      {
        const cstats = tf.contributor_stats || {};
        const allAuthors = new Map();
        for (const [author, pd] of Object.entries(cstats)) {
          let total = 0;
          for (const p of periods) {
            total += pd[p] ? (pd[p].reviews_received || 0) : 0;
          }
          if (total > 0) allAuthors.set(author, total);
        }
        const sorted = [...allAuthors.entries()].sort((a, b) => b[1] - a[1]);
        const topN = 15;
        const topAuthors = sorted.slice(0, topN).map(([u]) => u);
        const topSet = new Set(topAuthors);
        const palette = [
          'rgb(59, 130, 246)', 'rgb(249, 115, 22)', 'rgb(34, 197, 94)', 'rgb(168, 85, 247)',
          'rgb(236, 72, 153)', 'rgb(234, 179, 8)', 'rgb(20, 184, 166)', 'rgb(239, 68, 68)',
          'rgb(99, 102, 241)', 'rgb(244, 114, 182)', 'rgb(45, 212, 191)', 'rgb(251, 146, 60)',
          'rgb(129, 140, 248)', 'rgb(74, 222, 128)', 'rgb(232, 121, 249)',
        ];
        const rrDatasets = topAuthors.map((author, idx) => ({
          label: author,
          data: periods.map(p => (cstats[author] || {})[p] ? (cstats[author][p].reviews_received || 0) : 0),
          backgroundColor: palette[idx % palette.length],
          borderRadius: 4,
        }));
        rrDatasets.push({
          label: 'Others',
          data: periods.map(p => {
            let sum = 0;
            for (const [author, pd] of Object.entries(cstats)) {
              if (!topSet.has(author) && pd[p]) sum += pd[p].reviews_received || 0;
            }
            return sum;
          }),
          backgroundColor: 'rgb(107, 114, 128)',
          borderRadius: 4,
        });
        renderChart('chartReviewsRecvByAuthor', 'wrapReviewsRecvByAuthor', {
          labels, minBarWidth, stacked: true, datasets: rrDatasets,
        });
      }

      // Table
      const avgTTMAll = periods.map(p => tf.avg_time_to_merge[p] || 0);
      const medTTMAll = periods.map(p => tf.median_time_to_merge[p] || 0);
      const tbody = document.getElementById('tableBody');
      tbody.innerHTML = periods.map((p, i) => {
        const pct = unique[i] > 0 ? ((firstTime[i] / unique[i]) * 100).toFixed(1) : '0.0';
        return `<tr class="border-b border-gray-800 hover:bg-gray-800/50">
          <td class="py-2 px-3 font-medium whitespace-nowrap">${labels[i]}</td>
          <td class="py-2 px-3 text-right">${unique[i]}</td>
          <td class="py-2 px-3 text-right text-orange-400">${firstTime[i]}</td>
          <td class="py-2 px-3 text-right text-blue-400">${returning[i]}</td>
          <td class="py-2 px-3 text-right text-red-400">${noMerge[i]}</td>
          <td class="py-2 px-3 text-right">${pct}%</td>
          <td class="py-2 px-3 text-right text-green-400">${mergeAccess[i]}</td>
          <td class="py-2 px-3 text-right">${avgTTMAll[i]}d</td>
          <td class="py-2 px-3 text-right">${medTTMAll[i]}d</td>
          <td class="py-2 px-3 text-right text-purple-400">${prolific[i]}</td>
        </tr>`;
      }).join('');

      // Tab panels
      const defaultPeriod = periods[Math.max(0, periods.length - 2)];

      setupSelectPanel({
        selectEl: document.getElementById('selectAuthors'),
        listEl: document.getElementById('authorList'),
        periods, labels, defaultPeriod,
        getData: p => {
          const authors = tf.first_time_authors[p] || [];
          if (!authors.length) return '<p class="text-gray-500">No first-time authors in this period.</p>';
          return `<p class="text-gray-400 mb-3">${authors.length} first-time author${authors.length !== 1 ? 's' : ''}:</p>
            <div class="flex flex-wrap gap-2">${authors.map(a =>
              `<a href="https://github.com/${a}" target="_blank" rel="noopener"
                 class="inline-block bg-gray-800 hover:bg-gray-700 text-orange-400 px-3 py-1 rounded-full text-sm transition">${a}</a>`
            ).join('')}</div>`;
        },
      });

      setupSelectPanel({
        selectEl: document.getElementById('selectMergeAccess'),
        listEl: document.getElementById('mergeAccessList'),
        periods, labels, defaultPeriod,
        getData: p => {
          const users = tf.merge_access_users[p] || [];
          if (!users.length) return '<p class="text-gray-500">No one merged a PR in the last 30 days of this period.</p>';
          return `<p class="text-gray-400 mb-3">${users.length} contributor${users.length !== 1 ? 's' : ''} with merge access:</p>
            <div class="flex flex-wrap gap-2">${users.map(u =>
              `<a href="https://github.com/${u}" target="_blank" rel="noopener"
                 class="inline-block bg-gray-800 hover:bg-gray-700 text-green-400 px-3 py-1 rounded-full text-sm transition">${u}</a>`
            ).join('')}</div>`;
        },
      });

      setupSelectPanel({
        selectEl: document.getElementById('selectCommenters'),
        listEl: document.getElementById('commenterList'),
        periods, labels, defaultPeriod,
        getData: p => {
          const details = tf.prolific_commenter_details[p] || {};
          const entries = Object.entries(details);
          if (!entries.length) return `<p class="text-gray-500">No commenters with >${threshold} comments in this period.</p>`;
          return `<p class="text-gray-400 mb-3">${entries.length} commenter${entries.length !== 1 ? 's' : ''} with >${threshold} comments:</p>
            <div class="flex flex-wrap gap-2">${entries.map(([u, c]) =>
              `<a href="https://github.com/${u}" target="_blank" rel="noopener"
                 class="inline-flex items-center gap-1.5 bg-gray-800 hover:bg-gray-700 text-purple-400 px-3 py-1 rounded-full text-sm transition">
                 ${u}<span class="text-gray-500">${c}</span></a>`
            ).join('')}</div>`;
        },
      });

      // Contributor stats dropdown with per-period charts
      {
        const cstats = tf.contributor_stats || {};
        const authors = Object.keys(cstats);
        const selectEl = document.getElementById('selectContributor');
        const summaryEl = document.getElementById('contributorSummary');

        // Compute total PR count per author for the dropdown label
        function totalPRs(author) {
          const pd = cstats[author] || {};
          return Object.values(pd).reduce((s, v) => s + v.count, 0);
        }

        authors.sort((a, b) => totalPRs(b) - totalPRs(a));
        const defaultAuthor = authors[0] || '';
        selectEl.innerHTML = authors.map(a =>
          `<option value="${a}" ${a === defaultAuthor ? 'selected' : ''}>${a} (${totalPRs(a)} PRs)</option>`
        ).join('');

        function renderContributor(author) {
          const pd = cstats[author];
          if (!pd) {
            summaryEl.innerHTML = '<p class="text-gray-500">No data.</p>';
            return;
          }
          const total = totalPRs(author);
          const allTTM = [], allAdd = [], allDel = [], allCommits = [];
          for (const v of Object.values(pd)) {
            for (let i = 0; i < v.count; i++) {
              allTTM.push(v.avg_ttm);
              allAdd.push(v.avg_additions);
              allDel.push(v.avg_deletions);
              allCommits.push(v.avg_commits);
            }
          }
          const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(1) : '0';
          summaryEl.innerHTML = `
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Merged PRs</p>
                <p class="text-xl font-bold text-white mt-1">${total}</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Avg Time to Merge</p>
                <p class="text-xl font-bold text-white mt-1">${avg(allTTM)}d</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Avg Additions</p>
                <p class="text-xl font-bold text-green-400 mt-1">+${avg(allAdd)}</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Avg Deletions</p>
                <p class="text-xl font-bold text-red-400 mt-1">-${avg(allDel)}</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Avg Commits</p>
                <p class="text-xl font-bold text-white mt-1">${avg(allCommits)}</p>
              </div>
            </div>`;

          // Merged vs Closed PRs chart
          const mergedData = periods.map(p => pd[p] ? pd[p].count : 0);
          const closedData = periods.map(p => pd[p] ? (pd[p].closed_count || 0) : 0);
          renderChart('chartContribPRs', 'wrapContribPRs', {
            labels, minBarWidth, stacked: true,
            datasets: [
              { label: 'Merged', data: mergedData, backgroundColor: COLORS.green, borderRadius: 4 },
              { label: 'Closed', data: closedData, backgroundColor: COLORS.red, borderRadius: 4 },
            ],
          });

          // TTM + PR count chart
          const ttmData = periods.map(p => pd[p] ? pd[p].avg_ttm : null);
          const countData = periods.map(p => pd[p] ? pd[p].count : 0);
          renderChart('chartContribTTM', 'wrapContribTTM', {
            labels, minBarWidth, type: 'line',
            datasets: [
              { label: 'Avg TTM (days)', data: ttmData, borderColor: COLORS.blue, backgroundColor: 'rgba(59,130,246,0.1)', fill: false, tension: 0.3, pointRadius: 3, yAxisID: 'y', spanGaps: false },
              { label: 'PR count', data: countData, type: 'bar', backgroundColor: 'rgba(156,163,175,0.3)', borderColor: 'rgb(156,163,175)', borderWidth: 1, borderRadius: 4, yAxisID: 'y1' },
            ],
            yTitle: 'Days',
            secondaryY: { title: 'PRs', position: 'right' },
          });

          // Additions + deletions chart
          const addData = periods.map(p => pd[p] ? pd[p].avg_additions : null);
          const delData = periods.map(p => pd[p] ? pd[p].avg_deletions : null);
          const commitData = periods.map(p => pd[p] ? pd[p].avg_commits : null);
          renderChart('chartContribSize', 'wrapContribSize', {
            labels, minBarWidth, type: 'line',
            datasets: [
              { label: 'Avg additions', data: addData, borderColor: COLORS.green, backgroundColor: 'rgba(34,197,94,0.1)', fill: false, tension: 0.3, pointRadius: 3, yAxisID: 'y', spanGaps: false },
              { label: 'Avg deletions', data: delData, borderColor: COLORS.red, backgroundColor: 'rgba(239,68,68,0.1)', fill: false, tension: 0.3, pointRadius: 3, yAxisID: 'y', spanGaps: false },
              { label: 'Avg commits', data: commitData, borderColor: COLORS.orange, backgroundColor: 'rgba(249,115,22,0.1)', fill: false, tension: 0.3, pointRadius: 3, yAxisID: 'y1', spanGaps: false },
            ],
            yTitle: 'Lines',
            secondaryY: { title: 'Commits', position: 'right' },
          });

          // Comments per period chart
          const commentData = periods.map(p => pd[p] ? (pd[p].comments || 0) : 0);
          renderChart('chartContribComments', 'wrapContribComments', {
            labels, minBarWidth,
            datasets: [
              { label: 'Comments', data: commentData, backgroundColor: COLORS.purple, borderRadius: 4 },
            ],
          });

          // Reviews received per period chart
          const reviewsRecvData = periods.map(p => pd[p] ? (pd[p].reviews_received || 0) : 0);
          renderChart('chartContribReviewsRecv', 'wrapContribReviewsRecv', {
            labels, minBarWidth,
            datasets: [
              { label: 'Reviews Received', data: reviewsRecvData, backgroundColor: COLORS.blue, borderRadius: 4 },
            ],
          });
        }
        renderContributor(defaultAuthor);
        selectEl.onchange = () => renderContributor(selectEl.value);
      }

      // PR Stats section — activity heatmap per PR
      {
        const prStats = DATA.pr_activity || {};
        const prNumbers = Object.keys(prStats);
        // Sort by PR number descending (most recent first)
        prNumbers.sort((a, b) => parseInt(b) - parseInt(a));

        const searchEl = document.getElementById('prSearch');
        const selectPREl = document.getElementById('selectPR');
        const prSummaryEl = document.getElementById('prSummary');
        const prGraphEl = document.getElementById('prActivityGraph');

        let filteredPRs = prNumbers.slice();

        function populatePRDropdown(list) {
          // Limit to first 500 to keep the DOM reasonable
          const show = list.slice(0, 500);
          selectPREl.innerHTML = show.map(n => {
            const pr = prStats[n];
            const state = pr.merged ? 'merged' : (pr.closed ? 'closed' : 'open');
            return `<option value="${n}">#${n} ${pr.title} (${pr.author}, ${state})</option>`;
          }).join('');
          if (list.length > 500) {
            selectPREl.innerHTML += `<option disabled>... ${list.length - 500} more (search to narrow)</option>`;
          }
        }

        populatePRDropdown(filteredPRs);

        searchEl.oninput = () => {
          const q = searchEl.value.trim().toLowerCase();
          if (!q) {
            filteredPRs = prNumbers.slice();
          } else {
            filteredPRs = prNumbers.filter(n => {
              const pr = prStats[n];
              return n.includes(q) || pr.title.toLowerCase().includes(q) || pr.author.toLowerCase().includes(q);
            });
          }
          populatePRDropdown(filteredPRs);
          if (filteredPRs.length) renderPRStats(filteredPRs[0]);
        };

        function renderPRStats(prNum) {
          const pr = prStats[prNum];
          if (!pr) {
            prSummaryEl.innerHTML = '<p class="text-gray-500">No data.</p>';
            prGraphEl.innerHTML = '';
            return;
          }
          const state = pr.merged ? 'Merged' : (pr.closed ? 'Closed' : 'Open');
          const stateColor = pr.merged ? 'text-purple-400' : (pr.closed ? 'text-red-400' : 'text-green-400');
          function dayTotal(cats) { return Object.values(cats).reduce((s, v) => s + v, 0); }
          const totalEvents = Object.values(pr.activity).reduce((s, v) => s + dayTotal(v), 0);
          const activeDays = Object.keys(pr.activity).length;
          const firstResp = pr.first_response_days;
          const firstRespText = firstResp === null ? 'None' : firstResp < 1 ? '<1d' : firstResp + 'd';

          prSummaryEl.innerHTML = `
            <div class="flex flex-wrap gap-x-6 gap-y-2 items-center mb-4">
              <a href="https://github.com/bitcoin/bitcoin/pull/${prNum}" target="_blank" rel="noopener"
                class="text-blue-400 hover:underline font-medium">#${prNum}</a>
              <span class="${stateColor} font-medium">${state}</span>
              <span>by <a href="https://github.com/${pr.author}" target="_blank" rel="noopener"
                class="text-blue-400 hover:underline">${pr.author}</a></span>
              <span class="text-gray-500">Created ${pr.created}</span>
              ${pr.closed ? `<span class="text-gray-500">${pr.merged ? 'Merged' : 'Closed'} ${pr.closed}</span>` : ''}
            </div>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Participants</p>
                <p class="text-xl font-bold text-white mt-1">${pr.participants}</p>
                <p class="text-gray-500 text-xs mt-1">unique non-author</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">First Response</p>
                <p class="text-xl font-bold ${firstResp === null ? 'text-red-400' : firstResp <= 1 ? 'text-green-400' : firstResp <= 7 ? 'text-yellow-400' : 'text-orange-400'} mt-1">${firstRespText}</p>
                <p class="text-gray-500 text-xs mt-1">time to first review</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Comments Received</p>
                <p class="text-xl font-bold text-white mt-1">${pr.comments_received}</p>
                <p class="text-gray-500 text-xs mt-1">reviews + comments</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Author Follow-ups</p>
                <p class="text-xl font-bold ${pr.author_updates > 0 ? 'text-green-400' : 'text-gray-500'} mt-1">${pr.author_updates}</p>
                <p class="text-gray-500 text-xs mt-1">pushes/commits after open</p>
              </div>
              <div class="bg-gray-800 rounded-lg p-4">
                <p class="text-gray-400 text-xs">Longest Gap</p>
                <p class="text-xl font-bold ${pr.longest_gap_days > 90 ? 'text-red-400' : pr.longest_gap_days > 30 ? 'text-orange-400' : 'text-white'} mt-1">${pr.longest_gap_days}d</p>
                <p class="text-gray-500 text-xs mt-1">between active days</p>
              </div>
            </div>`;

          renderActivityHeatmap(pr, prGraphEl);
        }

        function renderActivityHeatmap(pr, container) {
          const activity = pr.activity || {};
          const dates = Object.keys(activity).sort();
          if (!dates.length) {
            container.innerHTML = '<p class="text-gray-500">No activity data.</p>';
            return;
          }

          // Date range: from created_at to last activity (or closed_at, whichever is later)
          const startDate = new Date(pr.created + 'T00:00:00');
          let endStr = dates[dates.length - 1];
          if (pr.closed && pr.closed > endStr) endStr = pr.closed;
          const endDate = new Date(endStr + 'T00:00:00');

          // Align start to previous Sunday
          const start = new Date(startDate);
          start.setDate(start.getDate() - start.getDay());

          // Align end to next Saturday
          const end = new Date(endDate);
          end.setDate(end.getDate() + (6 - end.getDay()));

          // Build weeks grid
          const weeks = [];
          let current = new Date(start);
          let week = [];
          while (current <= end) {
            const y = current.getFullYear();
            const m = String(current.getMonth() + 1).padStart(2, '0');
            const d = String(current.getDate()).padStart(2, '0');
            const dateStr = `${y}-${m}-${d}`;
            const cats = activity[dateStr] || {};
            const count = Object.values(cats).reduce((s, v) => s + v, 0);
            week.push({ date: dateStr, count, cats, day: current.getDay(), dayOfMonth: current.getDate(), month: current.getMonth() });
            if (week.length === 7) {
              weeks.push(week);
              week = [];
            }
            current.setDate(current.getDate() + 1);
          }
          if (week.length) weeks.push(week);

          // Color levels based on total counts per day
          const dayCounts = Object.values(activity).map(cats => Object.values(cats).reduce((s, v) => s + v, 0));
          const maxCount = Math.max(...dayCounts, 1);
          const levels = [
            Math.ceil(maxCount * 0.25),
            Math.ceil(maxCount * 0.5),
            Math.ceil(maxCount * 0.75),
          ];

          function getColor(count) {
            if (count === 0) return '#2d333b';
            if (count <= levels[0]) return '#0e4429';
            if (count <= levels[1]) return '#006d32';
            if (count <= levels[2]) return '#26a641';
            return '#39d353';
          }

          const cellSize = 12;
          const gap = 2;
          const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
          const dayLabels = ['', 'Mon', '', 'Wed', '', 'Fri', ''];

          // Tooltip element (shared, positioned on hover)
          const tooltipId = 'pr-heatmap-tooltip';

          let html = `<div style="position:relative;">`;
          html += '<div style="display: inline-flex; gap: 4px;">';

          // Day-of-week labels
          html += `<div style="display: flex; flex-direction: column; gap: ${gap}px; padding-top: 20px;">`;
          for (let d = 0; d < 7; d++) {
            html += `<div style="width: 28px; height: ${cellSize}px; line-height: ${cellSize}px; font-size: 10px; color: #8b949e;">${dayLabels[d]}</div>`;
          }
          html += '</div>';

          // Week columns
          html += `<div style="display: flex; gap: ${gap}px;">`;
          for (let w = 0; w < weeks.length; w++) {
            html += `<div style="display: flex; flex-direction: column; gap: ${gap}px;">`;
            const firstCell = weeks[w][0];
            const showMonth = firstCell.dayOfMonth <= 7;
            html += `<div style="height: 18px; font-size: 10px; color: #8b949e; white-space: nowrap;">${showMonth ? monthNames[firstCell.month] : ''}</div>`;

            for (let d = 0; d < weeks[w].length; d++) {
              const cell = weeks[w][d];
              const color = getColor(cell.count);
              // Encode event categories as a data attribute
              const catsJson = cell.count > 0 ? JSON.stringify(cell.cats).replace(/"/g, '&quot;') : '';
              html += `<div data-date="${cell.date}" data-cats="${catsJson}" data-count="${cell.count}"
                style="width:${cellSize}px;height:${cellSize}px;background:${color};border-radius:2px;"></div>`;
            }
            html += '</div>';
          }
          html += '</div></div>';

          // Tooltip div
          html += `<div id="${tooltipId}" style="display:none;position:fixed;z-index:50;pointer-events:none;
            background:#1c2128;border:1px solid #444c56;border-radius:6px;padding:8px 12px;font-size:12px;color:#e6edf3;
            box-shadow:0 4px 12px rgba(0,0,0,0.4);white-space:nowrap;"></div>`;

          // Legend
          html += `<div style="display:flex;align-items:center;gap:4px;margin-top:8px;font-size:11px;color:#8b949e;">
            <span>Less</span>
            <div style="width:${cellSize}px;height:${cellSize}px;background:#2d333b;border-radius:2px;"></div>
            <div style="width:${cellSize}px;height:${cellSize}px;background:#0e4429;border-radius:2px;"></div>
            <div style="width:${cellSize}px;height:${cellSize}px;background:#006d32;border-radius:2px;"></div>
            <div style="width:${cellSize}px;height:${cellSize}px;background:#26a641;border-radius:2px;"></div>
            <div style="width:${cellSize}px;height:${cellSize}px;background:#39d353;border-radius:2px;"></div>
            <span>More</span>
          </div>`;
          html += '</div>';

          container.innerHTML = html;

          // Attach hover listeners for the custom tooltip
          const tooltip = document.getElementById(tooltipId);
          container.addEventListener('mouseover', e => {
            const el = e.target;
            if (!el.dataset || !el.dataset.date) return;
            const date = el.dataset.date;
            const count = parseInt(el.dataset.count);
            if (count === 0) {
              let tip = `<strong>${date}</strong><br><span style="color:#8b949e;">No activity</span>`;
              tooltip.innerHTML = tip;
            } else {
              const cats = JSON.parse(el.dataset.cats);
              let tip = `<strong>${date}</strong><br>`;
              // Sort categories by count descending
              const entries = Object.entries(cats).sort((a, b) => b[1] - a[1]);
              for (const [cat, n] of entries) {
                tip += `<span style="color:#8b949e;">${n} ${cat}</span><br>`;
              }
              tooltip.innerHTML = tip;
            }
            tooltip.style.display = 'block';
            const rect = el.getBoundingClientRect();
            tooltip.style.left = (rect.left + rect.width / 2) + 'px';
            tooltip.style.top = (rect.top - 8) + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';
          });
          container.addEventListener('mouseout', e => {
            if (e.target.dataset && e.target.dataset.date) {
              tooltip.style.display = 'none';
            }
          });
        }

        if (prNumbers.length) {
          renderPRStats(prNumbers[0]);
        }
        selectPREl.onchange = () => renderPRStats(selectPREl.value);
      }
    }

    function renderChart(canvasId, wrapperId, { labels, datasets, stacked, minBarWidth, type, yTitle, secondaryY }) {
      // Destroy existing
      if (charts[canvasId]) {
        charts[canvasId].destroy();
        delete charts[canvasId];
      }

      // Set wrapper width for scrollable charts
      const wrapper = document.getElementById(wrapperId);
      const neededWidth = labels.length * (minBarWidth + 4);
      wrapper.style.minWidth = neededWidth > 600 ? neededWidth + 'px' : '';

      const ctx = document.getElementById(canvasId);
      const scales = {
        x: {
          grid: { display: false },
          stacked: !!stacked,
          ticks: {
            maxRotation: labels.length > 30 ? 90 : 0,
            autoSkip: true,
            maxTicksLimit: Math.min(labels.length, 40),
          },
        },
        y: {
          title: { display: true, text: yTitle || 'Count' },
          beginAtZero: true,
          stacked: !!stacked,
        },
      };
      if (secondaryY) {
        scales.y1 = {
          title: { display: true, text: secondaryY.title },
          beginAtZero: true,
          position: secondaryY.position || 'right',
          grid: { drawOnChartArea: false },
        };
      }

      const opts = {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
          legend: { display: true, position: 'top', labels: { boxWidth: 12, padding: 16 } },
        },
        scales,
      };

      charts[canvasId] = new Chart(ctx, {
        type: type || 'bar',
        data: { labels, datasets },
        options: opts,
      });
    }

    function setupSelectPanel({ selectEl, listEl, periods, labels, defaultPeriod, getData }) {
      selectEl.innerHTML = periods.map((p, i) =>
        `<option value="${p}" ${p === defaultPeriod ? 'selected' : ''}>${labels[i]}</option>`
      ).join('');
      listEl.innerHTML = getData(defaultPeriod);

      selectEl.onchange = () => {
        listEl.innerHTML = getData(selectEl.value);
      };
    }

    function formatPeriod(p, tf) {
      if (tf === 'year') return p;
      if (tf === 'quarter') {
        const [y, q] = p.split('-');
        return `${q} ${y}`;
      }
      if (tf === 'month') {
        const [y, m] = p.split('-');
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${months[parseInt(m) - 1]} ${y}`;
      }
    }

    function card(title, value, subtitle) {
      return `<div class="bg-gray-900 rounded-xl p-5 border border-gray-800">
        <p class="text-gray-400 text-sm">${title}</p>
        <p class="text-2xl font-bold text-white mt-1">${value}</p>
        <p class="text-gray-500 text-xs mt-1">${subtitle}</p>
      </div>`;
    }
  </script>
</body>
</html>
